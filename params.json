{
  "name": "ActiveRecord PHP",
  "tagline": "ActiveRecord in PHP",
  "body": "# ActiveRecord In PHP\r\n\r\n## Motivation\r\n\r\nI wrote this after having been spoiled by Ruby on Rails’ implementation\r\nof the ActiveRecord pattern, while still needing to work primarily in\r\nPHP. When I started this, there did exist some\r\n<acronym title=\"Object-relational mapping\">ORM</acronym> options in PHP.\r\nHowever, I wasn’t satisfied with any one in particular. My goals were to\r\ncreate an implementation that was very similar to the Rails syntax, easy\r\nto install, and fast.\r\n\r\n## Requirements\r\n\r\n-   PHP5\r\n-   Naming of tables and columns that follows the Rails convention.\r\n\r\n\r\n## Installation\r\n\r\n1.  Create your database and tables, if you haven’t already. (remember\r\n    use Rails’ conventions for table and column names)\r\n2.  Download [recent ActiveRecord release][] or\r\n\r\n        git clone https://github.com/lukebaker/activerecord-php.git\r\n\r\n3.  Untar into a models/ directory within your project or move checked\r\n    out directory activerecord-php/ into your models/ directory.\r\n4.  There should now be a models/activerecord-php/ directory, edit\r\n    models/activerecord-php/config.php to your liking.\r\n5.  Run models/activerecord-php/generate.php\r\n6.  This should have have generated model stubs inside your models/\r\n    directory. Edit these model files to tell ActiveRecord about the\r\n    relationships between tables. Do not edit \\*Base.php files as they\r\n    get overwritten every time you run generate.php\r\n7.  Use ActiveRecord, by including the models that you want to use:\r\n\r\n        require_once 'models/Post.php';\r\n\r\n  [recent ActiveRecord release]: https://github.com/lukebaker/activerecord-php/tags\r\n\r\n## Example\r\n\r\n### Create\r\n\r\n```php\r\n$p = new Post(array('title' => 'First Post!11!', 'body' => 'This is the body of my post'));\r\n$p->save(); # saves this post to the table\r\n \r\n$p2 = new Post();\r\n$p2->title = \"Second Post\";\r\n$p2->body = \"This is the body of the second post\";\r\n$p2->save(); # save yet another post to the db\r\n```\r\n\r\n### Retrieve\r\n\r\n```php\r\n$p = Post::find(1); # finds the post with an id = 1\r\n$p->title; # title of this post\r\n$p->body;  # body of this post\r\n \r\n# returns the 10 most recent posts in an array, assuming you have a column called \"timestamp\"\r\n$posts = Post::find('all', array('order' => 'timestamp DESC', 'limit' => 10));\r\n```\r\n\r\n### Update\r\n\r\n```php\r\n$p = Post::find(1);\r\n$p->title = \"Some new title\";\r\n$p->save(); # saves the change to the post\r\n \r\n# alternatively, the following is useful when a form submits an array\r\n$_POST['post'] = array('title' => 'New Title', 'body' => 'New body here!');\r\n$p = Post::find(1);\r\n$p->update_attributes($_POST['post']); # saves the object with these attributes updated\r\n```\r\n\r\n### Destroy\r\n\r\n```php\r\n$p = Post::find(1);\r\n$p->destroy();\r\n```\r\n\r\n### Relationships\r\n\r\n```php\r\n$p = Post::find(1);\r\n# call to $p->comments results in query to get all comments for this post\r\n# a subsequent call to $p->comments would not result in a query, but use results from previous query\r\nforeach ($p->comments as $comment) {\r\n  echo $comment->content;\r\n}\r\n```\r\n\r\n## Documentation\r\n\r\nWhile this attempts to document most of the features of ActiveRecord, it may not be entirely complete. I've tried to create tests for all pieces of functionality that exist in ActiveRecord. To view and / or run these tests check out the devel/ branch in the Subversion repository. In other words, there may be some functionality that is not documented here but is used in the tests.\r\n\r\nFor example purposes, let’s pretend we’re building a blog. You’ll have model classes which are each the model of a database table. Each model class is in a separate file. The stubs of these files are automatically generated for you by generate.php. Every time you update your database schema, you'll have to run generate.php again. It will not overwrite the files you've altered, but will overwrite the \\*Base.php files. Once you have the model stubs generated you can use them and work with the tables individually. However, in order to use the relationship specific abilities of ActiveRecord, you’ll need to specify the relationships in your models as outlined below in the Associations section.\r\n\r\n### Associations\r\n\r\nIn ActiveRecord we specify relationships between the tables in the model\r\nclasses. There are 3 types of relationships, 1:1, 1:many, and many:many.\r\n\r\n#### 1:1\r\n\r\nIn our example, blog posts have a 1:1 relationship with slugs. Here’s\r\nhow you’d specify that inside the Post and Slug classes.\r\n\r\n```php\r\n/* inside Post.php */\r\n  protected $has_one  = array('slug');\r\n\r\n/* inside Slug.php */\r\n  protected $belongs_to  = array('post');\r\n```\r\n\r\nIn a 1:1 relationship we must specify each side of the relationship\r\nslightly differently so that ActiveRecord knows the “direction” of the\r\nrelationship. We use belongs\\_to for the model whose table contains the\r\nforeign key (post\\_id in this case). The other side of the relationship\r\nuses has\\_one. Since an object could have multiple 1:1 relationships, we\r\nuse an array to allow for additional tables. Notice the singular use of\r\nslug and post. The code tries to read like English as much as possible,\r\nso later when we do 1:many relationships you’ll plural strings. After\r\nyou’ve specified this relationship you can do some extra things with\r\nyour models. On every slug and post object you can now do →post and\r\n→slug to get its post and slug respectively as an ActiveRecord object.\r\nAlso you set assign a slug or post using this mechanism. Furthermore, a\r\nsave will cascade to the relationship.\r\n\r\n```php\r\n$slug = Slug::find('first'); # SQL query to grab first slug\r\n$slug->post; # an SQL query occurs behind the scenes to find the slug's post\r\n\r\n$p = Post::find('first', array('include' => 'slug')); # SQL join\r\n$p->slug; # no SQL query here because we already got this post's slug in the SQL join in the previous line\r\n\r\n$p = Post::find('first');\r\n$s = new Slug(array('slug' => 'super-slug'));\r\n$p->slug = $s; # assign a slug to this post\r\n\r\n$p->slug->slug = 'foobar';\r\n$p->save(); # cascading save (post and slug are saved)\r\n```\r\n\r\n#### 1:many\r\n\r\nIn our example a post has many comments, but a comment only has one\r\npost. Here’s how you’d specify it in the Post and Comment classes.\r\n\r\n```php\r\n/* inside Post.php */\r\n  protected $has_many = array('comments');\r\n\r\n/* inside Comment.php */\r\n  protected $belongs_to = array('post');\r\n```\r\n\r\nNotice, we used plural “comments” for the has\\_many and a singular\r\n“post” for belongs\\_to. Also notice how the comments table contains the\r\nforeign key (post\\_id) and therefore is a belongs\\_to relationship. Once\r\nwe’ve done this Comment can do the same things as an 1:something\r\nrelationship can (see 1:1). Post now has some slight variations to the\r\nfeatures added in a 1:1 relationship. Now when accessing the attribute\r\ncomments you’d get an array of comment ActiveRecord objects that belong\r\nto this Post.\r\n\r\n```php\r\n$p = Post::find('first');\r\necho $p->comments[0]->body;\r\n```\r\n\r\nYou can also get the list of comment ids that belong to this post by\r\ncalling →comment\\_ids. You can set the ids in a similar fashion.\r\n\r\n```php\r\n$p = Post::find('first');\r\n$foo = $p->comment_ids;\r\n# foo is now an array of comment ids that belong to this post\r\narray_pop($foo); # pop off last comment id\r\narray_push($foo, 23); # and another comment id to $foo\r\n\r\n$p->comment_ids = $foo;\r\n/* this will remove the comment we popped off of foo\r\n    and add the comment we pushed onto foo to this post\r\n*/\r\n```\r\n\r\nYou can also push new objects onto the relationships.\r\n\r\n```php\r\n$c = new Comment(array('author' => 'anon', 'body' => 'first comment!!11'));\r\n$p->comments_push($c); # this call saves the new comment and associates with this post\r\n```\r\n\r\nIn this example, we might want to have comments destroyed when their\r\npost is destroyed or when they are disassociated with their post. You\r\ncan have this happen by specifying the relationship slightly\r\ndifferently. You can do this on any sort of relationship. Instead have\r\nthe following in the Post model.\r\n\r\n```php\r\n/* inside Post.php */\r\n  protected $has_many = array(array('comments' => array('dependent' => 'destroy')));\r\n```\r\n\r\n#### many:many\r\n\r\nA many:many relationship will have an intermediate table (and therefore\r\nmodel) which ties two other tables together. In our example, there is a\r\nmany:many relationship between posts and categories. Our intermediate\r\ntable is categorizations. Here is how that is specified:\r\n\r\n```php\r\n/* inside Categorization.php */\r\n  protected $belongs_to = array('post', 'category');\r\n\r\n/* inside Post.php */\r\n  protected $has_many = array(  'categorizations',\r\n                          array('categories' => array('through' => 'categorizations')));\r\n\r\n/* inside Category.php */\r\n  protected $has_many = array(  'categorizations', \r\n                          array('posts' => array('through' => 'categorizations')));\r\n```\r\n\r\nSince the categorizations table contains the foreign keys post\\_id and\r\ncategory\\_id, it has a belongs\\_to relationship with those. The Post\r\nmodel has a regular has\\_many relationship with categorizations and a\r\nspecial has\\_many relationship with categories. We specify which table\r\nthat relationship goes through (categorizations), IOW which table is the\r\nintermediate table of that relationship. The category to post\r\nrelationship is specified similarly. Posts and categories can now use\r\nthe special has\\_many methods documented in the 1:many relationship.\r\n\r\n### Working With Models\r\n\r\nThis section applies to all models regardless of any associations they\r\nmay have.\r\n\r\n#### Create\r\n\r\n```php\r\n$p = new Post(array('title' => 'First Post!11!', 'body' => 'This is the body of my post'));\r\n$p->save(); # saves this post to the table\r\n\r\n$p2 = new Post();\r\n$p2->title = \"Second Post\";\r\n$p2->body = \"This is the body of the second post\";\r\n$p2->save(); # save yet another post to the db\r\n```\r\n\r\n#### Retrieve\r\n\r\nRetrieving data involves finding the rows you want to look at and\r\nsubsequently grabbing the column data as needed. The first parameter for\r\nthe find method should be one of the following:\r\n\r\n-   an id number\r\n-   an array of id numbers\r\n-   the string “first”\r\n-   the string “all”\r\n\r\nWhen the first parameter is an id number or the string “first”, the\r\nresult will be an ActiveRecord object. Otherwise, it will be an array of\r\nActiveRecord objects. The find method takes quite a few different\r\noptions for its second parameter by using “named parameters” by\r\naccepting an array of key, value pairs. You can pass it the following\r\nkeys with sane values:\r\n\r\n-   limit\r\n-   order\r\n-   group\r\n-   offset\r\n-   select\r\n-   conditions\r\n-   include (for associations)\r\n\r\n```php\r\n$p = Post::find(1); # finds the post with an id = 1\r\n$p->title; # title of this post\r\n$p->body;  # body of this post\r\n\r\n# returns the 10 most recent posts in an array, assuming you have a column called \"timestamp\"\r\n$posts = Post::find('all', array('order' => 'timestamp DESC', 'limit' => 10));\r\n```\r\n\r\n#### Update\r\n\r\n```php\r\n$p = Post::find(1);\r\n$p->title = \"Some new title\";\r\n$p->save(); # saves the change to the post\r\n\r\n# alternatively, the following is useful when a form submits an array\r\n$_POST['post'] = array('title' => 'New Title', 'body' => 'New body here!');\r\n$p = Post::find(1);\r\n$p->update_attributes($_POST['post']); # saves the object with these attributes updated\r\n```\r\n\r\n#### Destroy\r\n\r\n```php\r\n$p = Post::find(1);\r\n$p->destroy();\r\n```\r\n\r\n#### Hooks\r\n\r\nThe following hooks are available, just define the method of the same\r\nname in the model that you want to use them:\r\n\r\n-   before\\_save\r\n-   before\\_create\r\n-   after\\_create\r\n-   before\\_update\r\n-   after\\_update\r\n-   after\\_save\r\n-   before\\_destroy\r\n-   after\\_destroy\r\n\r\n#### Escaping Query Values\r\n\r\nActiveRecord will do proper escaping of query values passed to where\r\npossible. However, it can’t do proper quoting when you do something like\r\nthe following.\r\n\r\n```php\r\n$p = Post::find('first', array('conditions' => \"title = {$_GET['title']}\"));\r\n```\r\n\r\nInstead you can use the quote static method to quote that value like so.\r\n\r\n```php\r\n$title = ActiveRecord::quote($_GET['title']);\r\n$p = Post::find('first', array('conditions' => \"title = $title\"));\r\n```\r\n\r\n#### Manual Queries\r\n\r\nOccasionally, though hopefully rarely, you may need to do specify some\r\nqueries by hand. You can use the query static method. This returns an\r\nassociative array with all the rows in it.\r\n\r\n```php\r\nActiveRecord::query(\"SELECT COUNT(*) FROM bar as b1, bar as b2 where b2.id != b1.id\");\r\n```\r\n\r\n### Table Structure For Example\r\n\r\n```sql\r\n--\r\n-- Table structure for table `categories`\r\n--\r\n\r\nCREATE TABLE `categories` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `name` varchar(255) DEFAULT NULL,\r\n  PRIMARY KEY  (`id`)\r\n) TYPE=MyISAM;\r\n\r\n--\r\n-- Table structure for table `categorizations`\r\n--\r\n\r\nCREATE TABLE `categorizations` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `post_id` int(11) DEFAULT NULL,\r\n  `category_id` int(11) DEFAULT NULL,\r\n  PRIMARY KEY  (`id`)\r\n) TYPE=MyISAM;\r\n\r\n--\r\n-- Table structure for table `comments`\r\n--\r\n\r\nCREATE TABLE `comments` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `author` varchar(255) DEFAULT NULL,\r\n  `body` text,\r\n  `post_id` int(11) DEFAULT NULL,\r\n  PRIMARY KEY  (`id`)\r\n) TYPE=MyISAM;\r\n\r\n--\r\n-- Table structure for table `posts`\r\n--\r\n\r\nCREATE TABLE `posts` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `title` varchar(255) DEFAULT NULL,\r\n  `body` text,\r\n  PRIMARY KEY  (`id`)\r\n) TYPE=MyISAM;\r\n\r\n--\r\n-- Table structure for table `slugs`\r\n--\r\n\r\nCREATE TABLE `slugs` (\r\n  `id` int(11) NOT NULL AUTO_INCREMENT,\r\n  `slug` varchar(255) DEFAULT NULL,\r\n  `post_id` int(11) NOT NULL,\r\n  PRIMARY KEY  (`id`)\r\n) TYPE=MyISAM;\r\n```\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}